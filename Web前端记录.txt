1. Html模板
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
</head>
<body>
</body>
</html>

2. Html引入css、js文件
<link type="text/css" href="" rel="stylesheet">
<script type="text/javascript" src=""></script>

3. js内置类型
空类型：null；
未定义类型：undefined；
布尔类型：Boolean；
数字类型：Number;
对象：Object；
字符类型：string；
符号:symbol (ES6新增)

4. 类型转换
toString()  转化为字符串，不可以转null和undefined
Number()    转换为数字，字符串中有一个不是数值的字符，返回NaN
parseInt()  转换为数字，第一个字符不是数字或者符号就返回NaN
String()    转换为字符串
Boolean()   转换为布尔值

5.可重定义 this 这个对象的方法
call()、apply()、bind() 

6. Cookie属性
name　　        字段为一个cookie的名称。
value　　       字段为一个cookie的值。
domain　        字段为可以访问此cookie的域名。
path　          字段为可以访问此cookie的页面路径。 比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie。
expires/Max-Age 字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。
                当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。
Size　　        字段 此cookie大小。
http　      　  字段  cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。
secure　　      字段 设置是否只能通过https来传递此条cookie

secure属性：
当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie 的具体内容。
HttpOnly属性：
如果在Cookie中设置了"HttpOnly"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。
Expire属性：
设置Cookie的失效时间

7. 检验是否为数组
方法一： instanceof:
var arr=[];
console.log(arr instanceof Array) //返回true
方法二： constructor:
console.log(arr.constructor == Array); //返回true
方法三： Array.isArray()
console.log(Array.isArray(arr)); //返回true

line-height 行间间距

8. 普通表格模板
<table>
    <!-- 表头 -->
    <thead>
        <!-- 行 -->
        <tr>
            <!-- 列 -->
            <th></th>
         </tr>
    </thead>
    <!-- 表内容 -->
    <tbody></tbody>
    <!-- 表页脚 -->
    <tfoot></tfoot>
</table>

9. forEach()
array.forEach(function(currentValue, index, arr), thisValue);

10. Object.defineproperty()在一个对象上定义一个新属性，或者修改一个对象的现有属性
Object.defineProperty(obj, prop, descriptor)
obj；要定义属性的对象。
prop;要定义或修改的属性的名称
descriptor:要定义或修改的属性描述符
let infornation = {
        'name': '小红',
        'age': 23
    }
Object.defineProperty(infornation, age, {
value:23,//JavaScript 值
enumerable:true,//控制属性是否可枚举，默认为flase
writable:true,//控制属性是否可被修改，默认为flase
configurable:true,//控制属性是否可被删除，默认为flase
 //当有人读取infornation的sex属性时，此函数就会被调用
    get() {
        return;
    },
    //当有人修改infornation的sex属性时，此函数就会被调用
    set(value) {

    }
})

11. 数据代理
需求 obj1 下有属性 x ,如何通过 obj2 修改 obj1.x？
let obj1={'x':100}
let obj2={};
Object.defineProperty(obj2,'x',{
    get(){
        return obj1.x;
    },
    set(value){
       return obj1.x=value;
    }
});

10. Vue 模板
let vm = new Vue({
    'el': '#app',
    data: {
        'age': 20,
        'firstName': '张',
        'lastName': '三'，
        'isHot': true
    },
    //方法
    methods: {
        showInfo(e) {
            console.log(e.keyCode);
            console.log('dsd');
        }
    },
    //计算属性
    computed: {
        fullname: {
            //1.有人读取fullname时，get就会被调用，且返回值就作为fullname的值
            //2.初次读取fullname调用
            get() {
                return this.firstName + this.lastName
            },
            //当fullname被修改时调用
            set(value) {

            }
        }
    },
    //实例被挂载后调用（初始化页面完成后，对dom节点进行相关操作）
    mounted: function() {
        document.querySelector('button').focus();
    }，
        //监听
    watch: {
        isHot: {
            immediate: true, //初始化是让handler调用一下
            deep:true,//深度监听，监听多级结构值
            //当isHot发生变化时,newValue(变化后的值)，oldVule(变化前的值)
            handler(newValue, oldVule) {

            }
        }
        //调用API监听
        //vm.$watch('isHot', function (newVal, oldVal) {
        //做点什么
        //})
    }，
    //过滤器
    filters{

    },
    //自定义指令
    directives{
        focus:{
            inserted (el,binding){
        }
        }
       
    }
});

11. Vue生命周期
vm的一生
将要创建 ==> 调用 beforeCreate 函数
创建完毕 ==> 调用 created 函数
将要挂载 ==> 调用 beforeMount 函数
挂载完毕 ==> 调用 mounted 函数
将要更新 ==> 调用 beforeUpdate 函数
更新完毕 ==> 调用 updated 函数
将要销毁 ==> 调用 beforeDestroy 函数
创建完毕 ==> 调用 destroyed 函数
new Vue({
    'el': '#app',
    'data': {},
    //初始化生命周期、事件完成,但代理数据还未开始
    beforeCreate() {

    },
    //初始化数据监测、数据代理完成
    created() {

    },
    //页面呈现未经Vue编译到DMO结构（Vue已生成虚拟DMO 在内存中），D对MO的操作，最终都不奏效
    beforeMount() {

    },
    mounted() {

    },
    //页面是旧的，但数据是新的
    beforeUpdate() {

    },
    //页面是新的，数据也是新的
    updated() {

    },
    //销毁vm实例前，在此周期一般进行关闭定时器、取消订阅信息、解除绑定自定义事件等收尾操作
    beforeDestroy() {

    },
    //销毁vm实例
    destroyed() {

    }
});

12. Vue组件
步骤：1. 创建组件 2. 注册组件 3. 使用组件
使用 Vue.extend 创建
const weather = Vue.extend({
    'template': `<div>天气<span>{{hot}}</span></div>`,
    'data': function() {
        return {
            hot: '热'
        }
    }
});
使用 components 注册组件
局部注册
const vm = new Vue({
    'el': '#app',
    'components': {
        weather
    }
})
全局注册
Vue.component('weather', Vue.extend({ /* ... */ }))
使用组件
<body>
    <div id="app">
        <weather></weather>
    </div>
</body>

13. 数组原生方法
pop、push、shift、unshift、foreach、map、filte、slice、splic、sort、reverse、some、every、reducce、concat、join、indexOf、lastIndexOf

14. 安装 vue 脚手架
第一步：全局安装@vue/cli
npm install -g @vue/cli
第二步：切换到你要创建项目的目录，然后使用命令创建项目
vue create '项目名称'
第三步：启动项目 （到创建的项目目录下）
npm run serve

查看webpack配置
vue inspect > output.js

Local:   http://localhost:8080/
Network: http://192.168.1.3:8080/

15.实现水平垂直居中
方法一：父元素设置：display:flex; justify-content:center; align-items:center
方法二：父元素设置弹性盒display:flex; 子元素可以设置margin: auto;

15. vue路由守卫
全局路由守卫
//全局前置守卫
router.beforeResolve(function(to,from,next){

})
//全局后置守卫
router.afterEach((to, from) => {

})

路由独享守卫
beforeEnter:function(to, from){

}

组件守卫
const UserDetails = {
  template: `...`,
  //通过路由规则，进入该组件时被调用
  beforeRouteEnter(to, from) {
    // 在渲染该组件的对应路由被验证前调用
    // 不能获取组件实例 `this` ！
    // 因为当守卫执行时，组件实例还没被创建！
  },
  beforeRouteUpdate(to, from) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，
    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`
  },
  //通过路由规则，离开该组件时被调用
  beforeRouteLeave(to, from) {
    // 在导航离开渲染该组件的对应路由时调用
    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`
  },
}

16. vuex环境搭建
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex);
//该文件用于创建VUEX中最为核心的stroe

//准备actions 用于响应组件中的动作
const actions = {

}

//准备mutations 用于操作数据
const mutations = {

}

//准备state 用于存储数据
const state = {

}

const store = new Vuex.Store({
    actions,
    mutations,
    state
})

export default store 

 
17. flex布局
 容器中指定Flex布局
 .box{
    display:flex;
 }
 行内指定Flex布局
 .box{
    display:inline-flex;
 }

 容器六个属性设置
 1. flex-direction:决定容器内多个div的排列方向
 .box {
  flex-direction: row | row-reverse | column | column-reverse;
 }
 水平
 row:从左至右排列
 row-reverse:从右至左排列
 垂直
 column:从上往下排列
 column-reverse:从下往上排列
 
 2. flex-wrap: 决定一条水平轴上排不下,如何换行
 .box{
   flex-wrap: nowrap | wrap | wrap-reverse;
 }
 nowrap:不换行
 wrap:换行,第一行在上方
 wrap-reverse:换行,第一行在下方

 3. flex-flow: flex-direction 属性和 flex-wrap 属性的简写形式，默认值为row nowrap。
 
 4. justify-content:决定在主轴上的对齐方式
 .box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
 }
 flex-start（默认值）：左对齐
 flex-end：右对齐
 center： 居中
 space-between：两端对齐，项目之间的间隔都相等。
 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

 5. align-items
 .box {
   align-items: flex-start | flex-end | center | baseline | stretch;
 }
 交叉轴->容器top至容器bottom(头部至底部)
 flex-start：交叉轴的起点对齐。
 flex-end：交叉轴的终点对齐。
 center：交叉轴的中点对齐。
 baseline: 项目的第一行文字的基线对齐。
 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

 6. align-content:属性定义了多根轴线的对齐方式

 行内六个属性
 1. order:定义行内排列顺序.数值越小越靠前
 .item {
   order: <integer>;
 }

 2. flex-grow:定义行内内容放大比例
 .item {
   flex-grow: <number>; /* default 0 */
 }

 3. flex-shrink:定义行内内容缩小比例
 .item {
  flex-shrink: <number>; /* default 1 */
 }

 4. flex-basis

 5. flex:属性是 flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。

 6. align-self

18. 格式化日期方法 
 function getDate(type,dateNum){
  var date;
  if(dateNum === ''){
    return '';
  }
  if(dateNum!=null){
    date = new Date(dateNum);
  }else{
    date = new Date();
  }
  var Y = date.getFullYear();
  var M = date.getMonth()+1 > 9?date.getMonth()+1:'0'+parseInt(date.getMonth()+1);
  var D = date.getDate()>9?date.getDate():'0'+date.getDate();
  var week = ['日','一','二','三','四','五','六'][date.getDay()];
  var H = date.getHours()>9?date.getHours():'0'+date.getHours();
  var m = date.getMinutes()>9?date.getMinutes():'0'+date.getMinutes();
  var s = date.getSeconds()>9?date.getSeconds():'0'+date.getSeconds();
  var time = '';
  if(type == 1){
    time = Y+'-'+M+'-'+D;
  }else if(type == 2){
    time = Y+'-'+M+'-'+D+' '+H+':'+m+':'+s;
  }else if(type == 3){
    time = Y+'-'+M;
  }else if(type == 4){
    time = Y+'-'+M+'-'+D+' '+H+':'+m;
  }else{
    time = Y+' 年 '+M+' 月 '+D+' 日 &nbsp;&nbsp;&nbsp; 星期'+week;
  }
  return time;
}

19. 推算往前几天或退后几天的日期
 //获取往前推的日期，// type = d,num 为往前推几天；// type = w,num 为往前推几周；// type = m,num 为往前推几月； this.$getDate此方法为(18)格式化时间方法
 export function getDatePrev (type,num){
  var time = '';
  if(num===''||num===undefined||num===null){
    return '';
  }
  if(type === 'd'){
    time = this.$getDate(1,new Date().getTime() - num * 24 *60 *60 * 1000);
  }else if(type === 'w'){
    time = this.$getDate(1,new Date().getTime() - num * 7 * 24 *60 *60 * 1000);
  }else if(type === 'm'){
    time = this.$getDate(1,new Date().getTime() - num * 30 * 24 *60 *60 * 1000);
  }

  return time;
}

20. 数字转中文 例如:1->一 2->二
 function numToChinese(num) {
  let numArr = ["零","一","二","三","四","五","六","七","八","九"];
  let numLimit = ["亿","万",""];//设置数字上限
  let numUnit = ["千","百","十",""];
  //num四位数是一个阶段对应 numLimit 每个阶段对应一个 numUnit，每个数字对应numArr。
  num = num.toString();
  num = num.split('');
  while (num.length < numLimit.length*4){
    num.unshift('');
  }
  // console.log(num)
  let numLength = num.length;
  let str = "";
  let limit = Math.ceil(numLength/4);
  // console.log(limit)
  for(let i = 1;i <= limit;i++){
    let start = (i -1) * 4;
    let end = i * 4;
    let limitNum = num.slice(start,end);
    // console.log(limitNum)
    for(let j = 0;j <limitNum.length ;j++){
      if(limitNum[j]!==''){
        let char = numArr[limitNum[j]];
        let unit = numUnit[j];
        if(limitNum[j] == 0){
          unit = '';
        }
        str += char+unit;
      }
    }
    let hasValue = limitNum.filter(val=>{
      return val!=='';
    });
    str = str.replace(/(零{2,})/,'零');//中间超过两个零替换为一个零
    if(str!=='零'){
      str = str.replace(/(零*)$/,'');//结尾去掉零
    }
    if(hasValue.length > 0){
      str+=numLimit[i-1];
    }
  }

  str = str.replace(/^一十/,'十');
  return str;
}

21. vue $event获取当前Dmo元素
 e.currentTarget;//绑定事件的元素
 e.currentTarget.children//绑定事件的子元素
 e.srcElement.style.background="red";//可以对获取的元素进行操作
 e.currentTarget.previousElementSibling.innerHTML;//获得点击元素的前一个元素
 e.currentTarget.firstElementChild;//获得点击元素的第一个子元素
 e.currentTarget.nextElementSibling;//获得点击元素的下一个元素
 e.currentTarget.getElementById("string");//获得点击元素中id为string的元素
 e.currentTarget.getAttributeNode('string');//获得点击元素的string属性
 e.currentTarget.parentElement;//获得点击元素的父级元素
 e.currentTarget.previousElementSibling.firstElementChild.innerHTML;//获得点击元素的前一个元素的第一个子元素的HTML值

22.父组件访问子组件方法 
方法一
this.$refs['子组件'].子组件方法名；
方法二
或 通过组件的$emit、$on方法
父组件：this.$refs['子组件'].$emit("子组件方法名")

23.子组件访问父组件方法
方法一
this.$partent.父组件方法名
方法二
在子组件中通过用$emit触发父组件中的方法
方法三
父组件把方法传入子组件中，子组件即可直接调用

24.兄弟组件之间传值
方法一
通过借用中央事件总线bus
在外部建立Bus.js文件，Bus.js文件中实例化vue，然后兄弟组件分别引入Bus.js文件，
例:
兄弟组件A监听方法send
Bus.$on('send',(data)=>{})
兄弟组件B触发方法send
Bus.$emit('send',(data)=>{})
方法二
在main.js，vue原型上添加Bus对象
Vue.prototype.bus=new Vue();
兄弟组件A监听方法send
this.bus.$on('send',function(data){})
兄弟组件B触发方法send
this.bus.$emit('send',data)

//解决两个数相加精度丢失问题
export function floatsum(a,b){
  if(a==undefined){return}
  if(b==undefined){return}
  if(a==0){a='0'}
  if(b==0){b='0'}
  let c = 0,d = 0,
    e = a.toString(),
    f = b.toString();
  // console.log(e)
  // console.log(f)
  try {
    c += e.split(".")[1].length;
  } catch (f) {
    // console.log(f)
  }
  try {
    d += f.split(".")[1].length;
  } catch (f) {
    // console.log(f)
  }

  let jd = c > d?c:d;
  // console.log(c)
  // console.log(e)
  // console.log(f)
  if(jd > 0){
    let numstr1 = e.replace(".", "")+`${Math.pow(10, (jd-c)).toString().slice(1)}`;
    let numstr2 = f.replace(".", "")+`${Math.pow(10, (jd-d)).toString().slice(1)}`;
    return (Number(numstr1) + Number(numstr2)) / Math.pow(10,jd);
  }else{
    return Number(e)+Number(f);
  }
  // return parseFloat(((e * Math.pow(10, c)) + (f *Math.pow(10, c)))/Math.pow(10, c));
}

/**解决两个数相乘精度丢失问题*/
export function floatMul(a, b) {
  if(a==undefined){return}
  if(b==undefined){return}
  if(a==0){a='0'}
  if(b==0){b='0'}
  var c = 0,
    d = a.toString(),
    e = b.toString();
  try {
    c += d.split(".")[1].length;
  } catch (f) {
    // console.log(f)
  }
  try {
    c += e.split(".")[1].length;
  } catch (f) {
    // console.log(f)
  }
  return Number(d.replace(".", "")) * Number(e.replace(".", "")) / Math.pow(10, c);
}
/**解决两个数相除精度丢失问题*/
export function floatDiv(arg1, arg2) {
  var r1 = arg1.toString(),
    r2 = arg2.toString(),
    m, resultVal, d = arguments[2];
  m = (r2.split(".")[1] ? r2.split(".")[1].length : 0) - (r1.split(".")[1] ? r1.split(".")[1].length : 0);
  resultVal = Number(r1.replace(".", "")) / Number(r2.replace(".", "")) * Math.pow(10, m);
  return typeof d !== "number" ? Number(resultVal) : Number(resultVal.toFixed(parseInt(d)));
}
/**解决两个数相减精度丢失问题*/
export function floatSub(arg1, arg2) {
  var r1, r2, m, n;
  try {
    r1 = arg1.toString().split(".")[1].length
  }
  catch (e) {
    r1 = 0
  }
  try {
    r2 = arg2.toString().split(".")[1].length
  }
  catch (e) {
    r2 = 0
  }
  m = Math.pow(10, Math.max(r1, r2))
  n=(r1>=r2)?r1:r2;
  return ((arg1*m-arg2*m)/m)
}

//日期格式化
function (dateStr,fmt){
  //防止2021-05-13T16:00:00.000Z格式包含000Z出现问题
  // date=new Date(date.toISOString().replace(/T/g, ' ').replace(/\.[\d]{3}Z/, ''));
  if(!dateStr)return '';
  let date = new Date(dateStr);

  if(date.toString()==='Invalid Date'){
    if(dateStr.toString().indexOf('-') > -1){
      date = new Date(dateStr.toString().replace(/-/g,'/'));
    }else{
      return '';
    }
  }

  var o = {
    "M+" : date.getMonth()+1, //月份
    "d+" : date.getDate(), //日
    "h+" : date.getHours()%12 == 0 ? 12 : date.getHours()%12, //小时
    "H+" : date.getHours(), //小时
    "m+" : date.getMinutes(), //分
    "s+" : date.getSeconds(), //秒
    "q+" : Math.floor((date.getMonth()+3)/3), //季度
    "S" : date.getMilliseconds() //毫秒
  };
  if(/(y+)/.test(fmt))
    fmt=fmt.replace(RegExp.$1, (date.getFullYear()+"").substr(4 - RegExp.$1.length));
  for(var k in o)
    if(new RegExp("("+ k +")").test(fmt))
      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length)));
  return fmt;
};